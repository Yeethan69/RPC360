#include <xtl.h>
#include <time.h>
#include <fstream>

#include "WebSocket.h"
#include "WebHelpers.h"

#include "RPC360.h"
#include "XexUtils.h"
#include "json.h"
#include "Discord.h"

bool g_setup = false;
bool g_main_exiting = false;
bool g_main_exited = false;
std::string g_token;
discord::gateway_client* g_client_pointer = nullptr;

extern "C" {
	bool XamIsCurrentTitleDash(
		void
	);
}

bool resolve_dns(const char* domain, char* ip, int ip_size) {
	XNDNS* pxndns = nullptr;
    if (XNetDnsLookup(domain, (WSAEVENT)nullptr, &pxndns) != 0)
        return false;

    for (int i = 0; i < 5 && pxndns->iStatus == WSAEINPROGRESS; ++i)
        Sleep(1000);

    if (pxndns->iStatus != 0 || pxndns->cina == 0) {
        XNetDnsRelease(pxndns);
        return false;
    }

    XNetInAddrToString(pxndns->aina[0], ip, ip_size);
    XNetDnsRelease(pxndns);
    return true;
}

std::string loaded_xex() {
	std::string filename = std::string(ExLoadedImageName);
	filename = filename.substr(filename.find_last_of("\\") + 1);
	filename = filename.substr(0, filename.length() -4);
	return filename;
}

std::pair<std::string, std::string> get_info(uint32_t title_id) {
	std::string name("");
	std::string id("");

	if(title_id == 0) 
		name = loaded_xex() == "default" ? "Unknown" : loaded_xex();

	auto socket = XexUtils::Socket("xboxunity.net", 443, true);

	const unsigned char RSA_DN[] = {
        0x30, 0x4F, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
        0x02, 0x55, 0x53, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x0A,
        0x13, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x65, 0x74, 0x20, 0x53,
        0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x65, 0x73, 0x65,
        0x61, 0x72, 0x63, 0x68, 0x20, 0x47, 0x72, 0x6F, 0x75, 0x70, 0x31, 0x15,
        0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0C, 0x49, 0x53, 0x52,
        0x47, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x58, 0x31
	};

	const unsigned char RSA_N[] = {
		0xAD, 0xE8, 0x24, 0x73, 0xF4, 0x14, 0x37, 0xF3, 0x9B, 0x9E, 0x2B, 0x57,
		0x28, 0x1C, 0x87, 0xBE, 0xDC, 0xB7, 0xDF, 0x38, 0x90, 0x8C, 0x6E, 0x3C,
		0xE6, 0x57, 0xA0, 0x78, 0xF7, 0x75, 0xC2, 0xA2, 0xFE, 0xF5, 0x6A, 0x6E,
		0xF6, 0x00, 0x4F, 0x28, 0xDB, 0xDE, 0x68, 0x86, 0x6C, 0x44, 0x93, 0xB6,
		0xB1, 0x63, 0xFD, 0x14, 0x12, 0x6B, 0xBF, 0x1F, 0xD2, 0xEA, 0x31, 0x9B,
		0x21, 0x7E, 0xD1, 0x33, 0x3C, 0xBA, 0x48, 0xF5, 0xDD, 0x79, 0xDF, 0xB3,
		0xB8, 0xFF, 0x12, 0xF1, 0x21, 0x9A, 0x4B, 0xC1, 0x8A, 0x86, 0x71, 0x69,
		0x4A, 0x66, 0x66, 0x6C, 0x8F, 0x7E, 0x3C, 0x70, 0xBF, 0xAD, 0x29, 0x22,
		0x06, 0xF3, 0xE4, 0xC0, 0xE6, 0x80, 0xAE, 0xE2, 0x4B, 0x8F, 0xB7, 0x99,
		0x7E, 0x94, 0x03, 0x9F, 0xD3, 0x47, 0x97, 0x7C, 0x99, 0x48, 0x23, 0x53,
		0xE8, 0x38, 0xAE, 0x4F, 0x0A, 0x6F, 0x83, 0x2E, 0xD1, 0x49, 0x57, 0x8C,
		0x80, 0x74, 0xB6, 0xDA, 0x2F, 0xD0, 0x38, 0x8D, 0x7B, 0x03, 0x70, 0x21,
		0x1B, 0x75, 0xF2, 0x30, 0x3C, 0xFA, 0x8F, 0xAE, 0xDD, 0xDA, 0x63, 0xAB,
		0xEB, 0x16, 0x4F, 0xC2, 0x8E, 0x11, 0x4B, 0x7E, 0xCF, 0x0B, 0xE8, 0xFF,
		0xB5, 0x77, 0x2E, 0xF4, 0xB2, 0x7B, 0x4A, 0xE0, 0x4C, 0x12, 0x25, 0x0C,
		0x70, 0x8D, 0x03, 0x29, 0xA0, 0xE1, 0x53, 0x24, 0xEC, 0x13, 0xD9, 0xEE,
		0x19, 0xBF, 0x10, 0xB3, 0x4A, 0x8C, 0x3F, 0x89, 0xA3, 0x61, 0x51, 0xDE,
		0xAC, 0x87, 0x07, 0x94, 0xF4, 0x63, 0x71, 0xEC, 0x2E, 0xE2, 0x6F, 0x5B,
		0x98, 0x81, 0xE1, 0x89, 0x5C, 0x34, 0x79, 0x6C, 0x76, 0xEF, 0x3B, 0x90,
		0x62, 0x79, 0xE6, 0xDB, 0xA4, 0x9A, 0x2F, 0x26, 0xC5, 0xD0, 0x10, 0xE1,
		0x0E, 0xDE, 0xD9, 0x10, 0x8E, 0x16, 0xFB, 0xB7, 0xF7, 0xA8, 0xF7, 0xC7,
		0xE5, 0x02, 0x07, 0x98, 0x8F, 0x36, 0x08, 0x95, 0xE7, 0xE2, 0x37, 0x96,
		0x0D, 0x36, 0x75, 0x9E, 0xFB, 0x0E, 0x72, 0xB1, 0x1D, 0x9B, 0xBC, 0x03,
		0xF9, 0x49, 0x05, 0xD8, 0x81, 0xDD, 0x05, 0xB4, 0x2A, 0xD6, 0x41, 0xE9,
		0xAC, 0x01, 0x76, 0x95, 0x0A, 0x0F, 0xD8, 0xDF, 0xD5, 0xBD, 0x12, 0x1F,
		0x35, 0x2F, 0x28, 0x17, 0x6C, 0xD2, 0x98, 0xC1, 0xA8, 0x09, 0x64, 0x77,
		0x6E, 0x47, 0x37, 0xBA, 0xCE, 0xAC, 0x59, 0x5E, 0x68, 0x9D, 0x7F, 0x72,
		0xD6, 0x89, 0xC5, 0x06, 0x41, 0x29, 0x3E, 0x59, 0x3E, 0xDD, 0x26, 0xF5,
		0x24, 0xC9, 0x11, 0xA7, 0x5A, 0xA3, 0x4C, 0x40, 0x1F, 0x46, 0xA1, 0x99,
		0xB5, 0xA7, 0x3A, 0x51, 0x6E, 0x86, 0x3B, 0x9E, 0x7D, 0x72, 0xA7, 0x12,
		0x05, 0x78, 0x59, 0xED, 0x3E, 0x51, 0x78, 0x15, 0x0B, 0x03, 0x8F, 0x8D,
		0xD0, 0x2F, 0x05, 0xB2, 0x3E, 0x7B, 0x4A, 0x1C, 0x4B, 0x73, 0x05, 0x12,
		0xFC, 0xC6, 0xEA, 0xE0, 0x50, 0x13, 0x7C, 0x43, 0x93, 0x74, 0xB3, 0xCA,
		0x74, 0xE7, 0x8E, 0x1F, 0x01, 0x08, 0xD0, 0x30, 0xD4, 0x5B, 0x71, 0x36,
		0xB4, 0x07, 0xBA, 0xC1, 0x30, 0x30, 0x5C, 0x48, 0xB7, 0x82, 0x3B, 0x98,
		0xA6, 0x7D, 0x60, 0x8A, 0xA2, 0xA3, 0x29, 0x82, 0xCC, 0xBA, 0xBD, 0x83,
		0x04, 0x1B, 0xA2, 0x83, 0x03, 0x41, 0xA1, 0xD6, 0x05, 0xF1, 0x1B, 0xC2,
		0xB6, 0xF0, 0xA8, 0x7C, 0x86, 0x3B, 0x46, 0xA8, 0x48, 0x2A, 0x88, 0xDC,
		0x76, 0x9A, 0x76, 0xBF, 0x1F, 0x6A, 0xA5, 0x3D, 0x19, 0x8F, 0xEB, 0x38,
		0xF3, 0x64, 0xDE, 0xC8, 0x2B, 0x0D, 0x0A, 0x28, 0xFF, 0xF7, 0xDB, 0xE2,
		0x15, 0x42, 0xD4, 0x22, 0xD0, 0x27, 0x5D, 0xE1, 0x79, 0xFE, 0x18, 0xE7,
		0x70, 0x88, 0xAD, 0x4E, 0xE6, 0xD9, 0x8B, 0x3A, 0xC6, 0xDD, 0x27, 0x51,
		0x6E, 0xFF, 0xBC, 0x64, 0xF5, 0x33, 0x43, 0x4F
	};

	const unsigned char RSA_E[] = { 0x01, 0x00, 0x01 };

	HRESULT hr_anchor = socket.AddRsaTrustAnchor(RSA_DN, sizeof(RSA_DN), RSA_N, sizeof(RSA_N), RSA_E, sizeof(RSA_E));
	if (FAILED(hr_anchor)) {
	    XexUtils::Log::Print("Couldn't add RSA trust anchor. HRESULT: 0x%08X", hr_anchor);
	}
	
	//Connect the underlying TLS socket
	HRESULT hr_connect = socket.Connect();
	if (FAILED(hr_connect)) {
		XexUtils::Log::Print("Couldn't establish underlying TCP/TLS connection to %s. HRESULT: 0x%08X", "xboxunity.net", hr_connect);
	}

	std::string path_template = "/Resources/Lib/TitleList.php?page=0&count=1&search={SEARCH}&sort=3&direction=1&category=0&filter=0";
	std::string path;

	std::string search;

	if(title_id != 0) {
		search.resize(8);
		sprintf((char*)search.c_str(), "%X", title_id);
		id = search;
	}
	else // search for name instead
		search = loaded_xex();

	size_t pos = path_template.find("{SEARCH}");
	if (pos != std::string::npos) {
	    path = path_template;
	    path.replace(pos, std::string("{SEARCH}").length(), search);
	}
	else 
	    path = "";

	if(path.empty())
		return std::make_pair(name, id);

	std::stringstream request;
	request << "GET "<< path.c_str() <<" HTTP/1.1\r\n";
	request << "Host: xboxunity.net\r\n";
	request << "Connection: close\r\n";
	request << "\r\n";;

	int bytesSent = socket.Send(request.str().c_str(), request.str().length());
	if (bytesSent != request.str().length()) {
	    XexUtils::Log::Print("Not all packets were sent");
	    socket.Disconnect();
		return std::make_pair(name, id);
	}

	std::string response_buffer;
	char buffer[1024];
	memset(buffer, '\0', sizeof(buffer));
	int r = 0;
	while ((r = socket.Receive(buffer, sizeof(buffer) - 1)) > 0) {
	   buffer[r] = '\0';
	   response_buffer.append(buffer, r);
	   memset(buffer, '\0', sizeof(buffer));
	}

	std::string json_payload_str = web::get_chunked_body(response_buffer);

	socket.Disconnect();

	Json::Value json;
	Json::Reader reader;
	if(!reader.parse(json_payload_str, json)) {
		std::cout << reader.getFormattedErrorMessages() << std::endl;
		return std::make_pair(name, id);
	}

	bool is_dash = XamIsCurrentTitleDash();
	return std::make_pair(is_dash ? "Dashboard" : json["Items"][0]["Name"].asString(), json["Items"][0]["TitleID"].asString());
}

uint32_t get_og_xbox_title_id() {
	std::ifstream stream("game:\\default.xbe", std::ios::binary);
	if(!stream) {
		XexUtils::Log::Print("Can't open XBE.");
		return 0xFFFFF7D2;
	}
	stream.seekg(260, std::ios::beg); //BaseAddress
	uint32_t base_addr;
	stream.read((char*)&base_addr, sizeof(base_addr));
	base_addr = _byteswap_ulong(base_addr);

	stream.seekg(280, std::ios::beg); //CertificateAddress
	uint32_t cert_addr;
	stream.read((char*)&cert_addr, sizeof(cert_addr));
	cert_addr = _byteswap_ulong(cert_addr);

	uint32_t title_id_addr = cert_addr - base_addr + 8; //TitleID offset
	uint32_t title_id;
	stream.seekg(title_id_addr, std::ios::beg);
	stream.read((char*)&title_id, sizeof(title_id));
	return _byteswap_ulong(title_id);
}

void main(void* module) {
	uint32_t current_title_id = 0xDEADBEEF;
	std::string current_title_name = "";

	auto *data_table = static_cast<LDR_DATA_TABLE_ENTRY *>(module);
	std::wstring w_path = std::wstring(data_table->FullDllName.Buffer);

	std::string path = std::string(w_path.begin(), w_path.end());
	std::string hdd_base = "\\Device\\Harddisk0\\Partition1\\";
	std::string usb_base = "\\Device\\Mass0\\";

    std::string dll_path_string;

	if (path.find(usb_base) != path.npos) {
		dll_path_string.append("usb:\\");
		dll_path_string.append(path.substr(usb_base.length()));
		XexUtils::Fs::MountUsb();
	}
	else if (path.find(hdd_base) != path.npos) {
		dll_path_string.append("hdd:\\");
		dll_path_string.append(path.substr(hdd_base.length()));
		XexUtils::Fs::MountHdd();
	}

    XexUtils::Fs::Path parent = XexUtils::Fs::Path(dll_path_string).Parent();
	XexUtils::Fs::Path config = parent.Append("config.json");

	std::ifstream stream(config.String(), std::ios::binary | std::ios::ate);
	if(!stream) {
		XexUtils::Log::Print("No config file, aborting.");
		g_main_exiting = true;
		g_main_exited = true;
		return;
	}

	std::streamsize size = stream.tellg();
	stream.seekg(0, std::ios::beg);

	std::vector<char> buffer(size);
	stream.read(buffer.data(), size);
	std::string json_string = std::string(&buffer[0]);

	Json::Value json;
	Json::Reader reader;
	if(!reader.parse(json_string, json)) {
		XexUtils::Log::Print("Error parsing json: %s", reader.getFormattedErrorMessages());
		g_main_exiting = true;
		g_main_exited = true;
		return;
	}

	g_token = json["Config"]["Token"].asString();
	std::string console = json["Config"]["Console"].asString();

	g_client_pointer = new discord::gateway_client(g_token);
	g_client_pointer->start();

	DWORD last_sent = 0;
	
    while (!g_main_exiting) {
		Sleep(1000);
		uint32_t new_title_id = XamGetCurrentTitleId();
		std::string new_title_name = loaded_xex();
		if (new_title_id == 0xFFFFF7D2)
			new_title_id = get_og_xbox_title_id();

		if (new_title_id != current_title_id || current_title_name != new_title_name || GetTickCount() - last_sent >= 30000) {
			XexUtils::Log::Print("TitleID: %X - Name: %s", new_title_id, new_title_name.c_str());
			Sleep(3000); //Crash otherwise
			auto info = get_info(new_title_id);
			std::string image = g_client_pointer->proxy_image("http://xboxunity.net/Resources/Lib/Icon.php?tid=" + info.second);
			g_client_pointer->send_rpc(info.first, image, GetTickCount(), console);
			last_sent = GetTickCount();
		}

        current_title_id = new_title_id;
		current_title_name = new_title_name;
    }

	delete g_client_pointer;
	g_main_exited = true;

}

int DllMain(HANDLE hModule, DWORD reason, void *pReserved) {
    switch (reason) {
		case DLL_PROCESS_ATTACH:
			XexUtils::Log::Print("RPC Loaded");
			XexUtils::ThreadEx(reinterpret_cast<PTHREAD_START_ROUTINE>(main), hModule, EXCREATETHREAD_FLAG_SYSTEM, NULL);
			break;

		case DLL_PROCESS_DETACH:
			g_main_exiting = true;
			g_discord_exiting = true;
			while(!g_main_exited || !g_discord_exited)
				Sleep(10);
			
			XexUtils::Log::Print("RPC Unloaded");
			break;
    }

    return TRUE;
}